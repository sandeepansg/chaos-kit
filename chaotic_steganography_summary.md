
# Chaotic Steganography System: Architecture and Mathematical Foundations

## Overview

This project implements a modern, modular steganography system enhanced by chaos theory and advanced cryptographic methods. It uses hyperchaotic systems, Chebyshev polynomial-based key exchange, and dynamic S-boxes to embed encrypted messages in digital images securely and stealthily.

---

## Architecture

### Layered System Design

```
+--------------------------+
|  CLI / REST API         |
+--------------------------+
|  Stego | Crypto | Chaos |
+--------------------------+
|      Core Engine        |
+--------------------------+
|  Image | Message | Key  |
+--------------------------+
```

### Folder Structure

```
chaotic_steganography/
├── src/
│   ├── chaos/         # Hyperchaotic generators
│   ├── crypto/        # S-box and Chebyshev methods
│   ├── stego/         # Embedding/extraction
│   └── utils/         # Entropy, image processing
├── cli/               # Command-line interface
├── api/               # FastAPI-based endpoints
└── tests/             # Unit and integration tests
```

---

## Mathematical Core

### 1. 5D Hyperchaotic System

Used to generate non-repeating pseudorandom sequences for encryption and pixel selection.

**Equations:**

Let state be (x, y, z, w, v), then:

```
dx/dt = a(y - x) + w  
dy/dt = c*x - y - x*z + v  
dz/dt = x*y - b*z  
dw/dt = -y*z + d*w  
dv/dt = -e*x + e*y + r*v
```

**Conditions:**

- a = 36.0, b = 3.0, c = 20.0, d = -1.0, e = -16.0, r = 1.0  
- Integration: 4th order Runge-Kutta  
- Time step dt = 0.001  
- Initial state derived from SHA-256 hash of key or random state

**Output:**  
Normalized chaos values mapped to pixel coordinates and embedding patterns.

---

### 2. Chebyshev Polynomial Key Exchange

Utilizes the semi-group property of Chebyshev polynomials for secure key exchange.

**Formulas:**

For Tₙ(x), the Chebyshev polynomial of the first kind:
```
Tₙ(x) = cos(n * arccos(x))          when |x| ≤ 1  
Tₙ(x) = cosh(n * acosh(x))         when |x| > 1
```

**Shared Secret Generation:**

Both parties compute:
```
K = T_priv(T_pub_other(x)) mod P
```
Where P is a large prime. This commutative structure ensures both sides derive the same key without revealing private values.

---

### 3. Dynamic S-Box Generation

S-Boxes are generated by shuffling byte values (0-255) using chaos-derived sequences and then validated.

**Validation Conditions:**

- Must be a bijection  
- Non-linearity threshold > 100  
- SAC deviation < 0.1  

Fallback logic perturbs seed if S-box fails validation.

---

## Embedding System

### Message Embedding Workflow

1. **Preprocessing:**
   - Message converted to bits with length header
   - Optional password-based encryption using dynamic S-box

2. **Capacity Estimation:**
   - Non-edge regions identified via Canny edge detection
   - 80% of suitable pixels reserved for embedding

3. **Channel Selection:**
   - Entropy and uniformity computed for R, G, B channels
   - Best channel selected dynamically

4. **Positioning:**
   - Chaos sequence maps to (x, y) pixel locations ensuring uniqueness

5. **Adaptive Embedding:**
   - Embedding strength (1–3 bit planes) determined by chaotic state magnitude
   - Multi-bit LSB embedding with redundancy

---

### Extraction Flow

1. **Auto-detect Channel:**
   - LSB randomness heuristics (e.g., run-length tests)

2. **Chaos Re-simulation:**
   - Same parameters regenerate pixel locations and bit strengths

3. **Bit Extraction:**
   - Majority logic used to recover message bits for >1-bit embeddings

4. **Decryption and Parsing:**
   - Inverse S-box and key stream applied
   - Header decodes original message length

---

## Optimization Hints

- Runge-Kutta tuning: Selective skipping of low-variance chaotic states
- Pixel skipping: Avoid visually sensitive or already-modified regions
- S-box caching: Store validated S-boxes per password session
- Parallelism: Batch processing of chaotic sequences and entropy checks
- Entropy balancing: Adjust embedding pattern to preserve original entropy profile

---

## Output Metrics

- Capacity Used: Message bits / total embeddable pixels  
- Entropy Change: Difference between pre and post-embedding entropy  
- Extraction Confidence: Heuristically estimated based on terminator check and decode success

---

## Security Considerations

- Statistical Detection Resistance: Adaptive embedding avoids regular patterns  
- Cryptographic Safety: Key-dependent chaos and S-boxes make brute-force infeasible  
- Tamper Resistance: Entropy deviation and RS analysis can be used to validate integrity  

---

This architecture allows a seamless blend of chaos theory, cryptographic rigor, and steganographic stealth, and is suitable for integration into both command-line tools and networked applications via RESTful API.
